# set과 dictionary로 탐색 속도 줄이기

- x in list는 시간복잡도가 O(n)이지만, x in set이나 x in dict는 시간복잡도가 **O(1)**이다!!
  - 이유인즉, 셋과 딕셔너리는 in으로 탐색할 때 해시를 사용하기 때문.
  - 두루두루 써먹을 수 있으니, 꼭 알아둘 것!



# Python 파일 입출력 구문

- input.txt와 output.txt를 사용할 때
  - SWEA 제출용 -> 예의 sys 구문들을 전부 제거한다 (처음부터 3번째 줄까지)

```python
import sys
sys.stdin = open('input.txt') # 이후 모든 input() 구문은 input.txt에서 가져옴
sys.stdout = open('output.txt', 'w') # 마찬가지로 모든 print() 구문이 output.txt에서 동작. w 설정은 기존 파일에 내용이 있어도 새로 덮어씌움

t = int(input()) # 일반 문자 입력
lst = [list(map(int, input().split())) for _ in range(100)] # 2차원 리스트 입력

print(f'#{t}') # f-string 문법으로 문자열 안에 변수의 값을 끼워넣어 출력
```

- BOJ 제출용

```python
import sys
input = sys.stdin.readline # input 구문을 readline으로 대체해야 입력 속도가 빨라진다

# 이후 input() 구문 문법은 동일!
```

- 문자열을 입력받을 때는?

```python
# rstrip을 써서 공백 및 줄바꿈 문자 제거
# list로 변환해서 저장
lst = list(input().rstrip())
```



# 2차원 리스트 초기화

```python
# n * n 리스트 초기화
lst = [[0] * n for _ in range(n)]
```



# Delta 탐색

```python
# 다음과 같은 델타 튜플을 상하, 좌우로 나누어 준비한다.
# 예시의 탐색 방향은 우, 하, 좌, 상 순서
dx = (0, 1, 0, -1)
dy = (1, 0, -1, 0)

# 사용방식 예시
for di in range(4):
    curX = dx[di]
    curY = dy[di]
```



# 리스트를 한 줄로 출력하기

```python
lst = [1, 2, 3, 4, 5]
# 1 2 3 4 5 출력

# 방식 1
for i in lst:
    print(i, end=' ')
# 방식 2 - List Comprehension
print(' '.join(str(i) for i in lst))

# 주의! 2차원 리스트를 출력할 때는 줄바꿈 출력을 꼭 넣어 줘야 한다!
print()
```



# 리스트를 사용한 스택 구현

```python
# 리스트 초기화
lst = []
lst.clear()

# 스택 push : 원소 1
lst.append(1)

# 스택 pop
p = lst.pop()
print(p)

# 보너스 : 리스트 얕은 복사와 순서 뒤집기
lst_cpy = lst[:]
lst_rev = lst[::-1]
```



# Deque 라이브러리를 활용한 큐 구현

```python
# 라이브러리 불러오기
from collections import deque
# 간혹 import collections를 써야 하는 경우도 있음... collections.deque라고 쓰면 됨

# 큐 생성하기
que = deque()
# 입력 받을 때 큐 형식으로 받기
que_in = deque(map(int, input().split()))

# 큐 inque
que.append(1)

# 큐 deque
d = que.popleft()
print(d)

# 큐의 얕은 복사
que_cpy = que.copy()
```



# 추가 예정

- BFS,  DFS 템플릿

- 람다 어떻게 썼더라?
- 3항 연산자?
- set의 합집합, 교집합 연산