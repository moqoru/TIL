# p173 두 수의 합

- 3번 풀이까지 가능, 코드 작성 완료
  - Big O와 해시 간략 설명?
  - in과 index를 쓰는게 효율적인 이유, 딕셔너리에서는 더 빠른 이유
  - 배열 슬라이싱을 쓰면 더 빠른 이유?

# p180 빗물 트래핑

- 투 포인터 풀이까진 이해했음
  - 결국 빗물은 산 모양으로 쌓이기 때문에, '산 꼭대기'를 투 포인터로 찾아가면서 중간에 양쪽 옆에서 최대 높이가 갱신될 때마다 빗물이 쌓이는 높이를 더 높여주면서 웅덩이를 센다.
  - 사실 if max<x then max=x가 너무 익숙해서 max(max,x)가 오히려 안 떠오른다...
- 코드 작성보다는 CT로 푸는게 쉬운 문제

# p184 세 수의 합

- 포기!!!!!
  - 어떻게든 설명은 될 거 같음.
  - 투 포인터는 정렬된 상황에서 두 수의 특정 조합을 찾을 때 쓸 수 있는 알고리즘.

# p190 배열 파티션1

- 이것도 풀이만 이해.
  - CT적으로 푸는 문제라고 생각, 가장 큰 수 조합에 그나마 큰 수 조합을 넣으려면 가장 큰 수 조합을 계속 골라내야 함. 결국 오름차순으로 골라 두개씩 순서대로 묶는게 가장 큼
  - 살펴보니 그냥 묶어서 홀수번째만 합치면 되잖아?

# p193 자신을 제외한 배열의 곱

- 이것도 CT 문제, 곱을 왼쪽, 오른쪽에서 순서대로 쭉 적어와서 그 자리 숫자마다 양 옆의 완성된 곱을 서로 곱하면 된다.
  - 예제에서는 오른쪽에서 적어오는 것과 완성된 곱을 곱하는 과정을 하나로 합쳤다.

# p195 주식을 사고팔기 가장 좋은 시점

- 이 문제는 투 포인터로는 못 풀 지도? 최대치를 찾는 문제는 어울리지 않는다.
- 처음부터 순서대로 보면서 현재까지의 최소값에서 샀을 때, 현재 값에 파는게 최대 이익인가?를 구현 
  - [3,6,2,4]인 경우를 위 방법으로 따지면서 생각해보면 된다.
