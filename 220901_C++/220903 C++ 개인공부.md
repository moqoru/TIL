## python 하다와서 헷갈리는 것

- if (0<= nx < y) 식으로 쓸 수는 없다... 분리해서 if (0 <= nx && nx < y )식으로 써야 함
- if (!n) 식으로 not 구문을 쓸 수 있음. 마찬가지로 0이 false, 나머지 값이 true 판정
  - false, true를 소문자로 써야 함!
  - 중첩될 때는 괄호 꼬박꼬박 붙이기! if(!(0>nx) && nx <y) 식으로 써야 안 헷갈림
- if조건문 뒤의 구문이 한 줄이면 그 다음줄에 들여쓰기 해서 쓰고 {}를 생략 가능
  - 사실 보닌이 그런 경우에는 한 줄에 몰아적기를 즐겨 써서 잘 안할거 같음;

## String 사용법?

- #include <string> 사용
  - s.substr(0, 1); => 0부터 1개의 글자를 잘라 string으로 저장할 수 있음
    - 첫번째 항목은 시작 위치, **두번째 항목은 글자 길이**인 것에 주의할 것!
  - stoi(s); => string 구문을 int형으로 바꿀 수 있음
    - 반대로 바꾸는 구문은 to_string(n);

## 포인터 복습?

- 포인터 선언과 할당 방법, 선언과 동시에 할당할 때는 int *pa = a, 나중에 할당할 때는 &을 사용

  - 나중에 할당할 때 *을 쓰면 아예 안 먹음;;;

  ```cpp
  #include <iostream>
  using namespace std;
  
  int *pa;
  
  int main()
  {
      int a = 1;
      pa = &a;
      a = 2;
      cout << *pa << endl;
  }
  ```

-  &는 그 변수의 주소값, *는 그 주소가 가리키는 변수

  - 그 변수가 저장된 메모리 상의 주소를 직접 찾아가기 때문에 서로 다른 함수라도 주소값을 받으면 찾아갈 수 있는 것.

## 배열을 한번에 같은 숫자로 초기화하려면?

- memset()을 쓰자!

  - 순서대로 배열 이름, 초기화 값, sizeof(이름)으로 사용.

  ```cpp
  int arr[10];
  memset(arr, 0, sizeof(arr));
  ```

- 주의사항! **되도록 0과 -1만 사용할 것!**

  - for문을 돌리는 것보다 약 5배정도 빠르지만, 그 과정에서 꼼수를 쓰기 때문에 아무 값이나 넣으면 초기화 자체가 이상하게 들어감...
    - 0b5f890393 => 0b5f 식으로 앞 두글자만 자름 => 0b5f5f5f5f 식으로 만듦
    - 0과 -1은 0b00000000, 0b11111111이므로 걱정없는 것.

## vector 헤더를 이용한 다차원 배열 사용법

- C++에서는 다차원 배열의 동적 할당을 못 하게 막아 두었다.
  - 사용하려면 1차원 배열을 대신 써서 다음과 같이 해야 함
    - 선언 : int *lst = new int[n * m];
    - 함수 호출 : def(lst)
    - 함수에서 사용 : void chunk(int* lst)
    - 해제 : delete lst

- 그래서 다차원 배열을 원래 쓰던 감각처럼 쓸 수 있는 STL의 vector 헤더를 사용!

```cpp
#include <vector>
// 선언과 동시에 할당하며 초기화
int n, m;
cin >> n >> m;
vector<vector<int>> lst(n, vector<int>(m, 0));
// 윗 구문 맨 뒤의 0은 초기값임! 안 적어줘도 원래 0으로 초기화되므로 걱정 말고 쓸 것!
// 선언과 할당을 따로 할 경우
vector<vector<int>> lst;
lst.resize(n, 0);
for (vector<int>&sub : lst) // 파이썬의 list 순회와 유사한 느낌.
    sub.resize(m,0);
// 함수 선언과 호출이 필요할 때는?
void mydef(int n, int m, vector<vector<int>> &lst) // 주소를 받기 때문에 지역으로 할당해도 사용가능
    mydef(n, m, lst);
```

- 덤 : 이 벡터 자료형은 스택과 유사하게 사용 가능
  - .push_back(n), .pop_back() 식으로 활용 가능
  - .size(), .empty()도 활용 가능
  - 하지만 삭제와 삽입이 빈번할 경우 차라리 stack이나 deque를 쓰는게 훨씬 낫다.
  - 일단은 여기까지. 지금은 STL까지 딥하게 배울 상황은 아닌듯.
- 하지만 만약 헤더 제한이 있거나 하는 경우, 그냥 **전역으로 넉넉하게 배열 할당해버리는 게 제일 편하기는 하다!**

## 추가로 배울 거

- stack, queue 라이브러리 배우기