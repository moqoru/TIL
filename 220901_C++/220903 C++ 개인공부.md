## C++ 구조체 사용법

```cpp
class namedata{
    public:
    string name, phone, location;
    namedata(string name, string phone, string location){
        this->name = name;
        this->phone = phone;
        this->location = location;
    }
    namedata(){} // 이걸 넣어야 생성과 할당을 따로 따로 할 수 있음.
    private:
};
```

- 소문자 class 뒤에 이름을 적고 {}로 감싸기, **오직 클래스만 끝날때 세미콜론(;)을 필수로 붙여야 한다.**
- public:으로 적은 공간은 외부에서 호출 가능, private:로 적은 공간은 외부에서 호출 불가
  - 일단 public과 private는 굳이 안 써도 되긴 하다.
- 클래스에서 사용할 변수를 먼저 선언해준 뒤 생성자를 적어준다.
  - 파이썬과는 다르게 그냥 클래스 이름을 한번 더 적으면 생성자로 처리됨
  - ()안에 사용할 변수를 죽 적어준다.
  - this->변수 = 변수 식이다. 자바와 비슷하면서도 다르니 주의...
- 이후 생성자를 (){} 식으로 한번 더 적으면 선언을 먼저 따로, 할당은 나중에 할 수 있다.

```cpp
namedata cls[n]; // 먼저 생성을 해 두고...
for (int i=0; i<n; i++){
    cin >> in_n >> in_p >> in_l;
    cls[i] = namedata(in_n, in_p, in_l); // 나중에 할당!
}
```

## sort 쓰는 법

- **#include \<algorithm> 사용 필수!**

- int A[4] = {1, 3, 2, 4};
- sort(A, A + 4);
  - 배열을 포인터처럼 생각해서 배열 변수, 변수 + 길이를 인자로 넣을 것!
  - sort(A, A+4, greater<>()); 로 적으면 내림차순 정렬 가능
  - 3번째 인자에 bool 함수를 넣으면 커스텀 정렬 가능!
    - 함수의 리턴은 return a<b 식으로, 앞쪽 인자가 뒤쪽 인자보다 작은 식으로 설정할 것! 
- 커스텀 정렬 함수를 이용해 구조체의 특정 변수 기준으로 정렬하기

```cpp
bool cmp(namedata a, namedata b){
    return a.name < b.name;
}
...
sort(cls, cls+n, cmp);
```

## python 하다와서 헷갈리는 것

- if (0<= nx < y) 식으로 쓸 수는 없다... 분리해서 if (0 <= nx && nx < y )식으로 써야 함
- if (!n) 식으로 not 구문을 쓸 수 있음. 마찬가지로 0이 false, 나머지 값이 true 판정
  - false, true를 소문자로 써야 함!
  - 중첩될 때는 괄호 꼬박꼬박 붙이기! if(!(0>nx) && nx <y) 식으로 써야 안 헷갈림
- if조건문 뒤의 구문이 한 줄이면 그 다음줄에 들여쓰기 해서 쓰고 {}를 생략 가능
  - 사실 보닌이 그런 경우에는 한 줄에 몰아적기를 즐겨 써서 잘 안할거 같음;
- 문자열을 쓸 때 ""만 사용 가능, '' 사용 불가.

## String 사용법?

- #include \<string> 사용
  - s.substr(0, 1); => 0부터 1개의 글자를 잘라 string으로 저장할 수 있음
    - 첫번째 항목은 시작 위치, **두번째 항목은 글자 길이**인 것에 주의할 것!
  - stoi(s); => string 구문을 int형으로 바꿀 수 있음
    - 반대로 바꾸는 구문은 to_string(n);

## 포인터 복습?

- 포인터 선언과 할당 방법, 선언과 동시에 할당할 때는 int *pa = a, 나중에 할당할 때는 &을 사용

  - 나중에 할당할 때 *을 쓰면 아예 안 먹음;;;

  ```cpp
  #include <iostream>
  using namespace std;
  
  int *pa;
  
  int main()
  {
      int a = 1;
      pa = &a;
      a = 2;
      cout << *pa << endl;
  }
  ```

-  &는 그 변수의 주소값, *는 그 주소가 가리키는 변수

  - 그 변수가 저장된 메모리 상의 주소를 직접 찾아가기 때문에 서로 다른 함수라도 주소값을 받으면 찾아갈 수 있는 것.

## 배열을 한번에 같은 숫자로 초기화하려면?

- memset()을 쓰자!

  - 순서대로 배열 이름, 초기화 값, sizeof(이름)으로 사용.

  ```cpp
  int arr[10];
  memset(arr, 0, sizeof(arr));
  ```

- 주의사항! **되도록 0과 -1만 사용할 것!**

  - for문을 돌리는 것보다 약 5배정도 빠르지만, 그 과정에서 꼼수를 쓰기 때문에 아무 값이나 넣으면 초기화 자체가 이상하게 들어감...
    - 0b5f890393 => 0b5f 식으로 앞 두글자만 자름 => 0b5f5f5f5f 식으로 만듦
    - 0과 -1은 0b00000000, 0b11111111이므로 걱정없는 것.

## vector 헤더를 이용한 다차원 배열 사용법

- C++에서는 다차원 배열의 동적 할당을 못 하게 막아 두었다.
  - 사용하려면 1차원 배열을 대신 써서 다음과 같이 해야 함
    - 선언 : int *lst = new int[n * m];
    - 함수 호출 : def(lst)
    - 함수에서 사용 : void chunk(int* lst)
    - 해제 : delete lst

- 그래서 다차원 배열을 원래 쓰던 감각처럼 쓸 수 있는 STL의 vector 헤더를 사용!

```cpp
#include <vector>
// 선언과 동시에 할당하며 초기화
int n, m;
cin >> n >> m;
vector<vector<int>> lst(n, vector<int>(m, 0));
// 윗 구문 맨 뒤의 0은 초기값임! 안 적어줘도 원래 0으로 초기화되므로 걱정 말고 쓸 것!
// 선언과 할당을 따로 할 경우
vector<vector<int>> lst;
lst.resize(n, 0);
for (vector<int>&sub : lst) // 파이썬의 list 순회와 유사한 느낌.
    sub.resize(m,0);
// 함수 선언과 호출이 필요할 때는?
void mydef(int n, int m, vector<vector<int>> &lst) // 주소를 받기 때문에 지역으로 할당해도 사용가능
    mydef(n, m, lst);
```

- 덤 : 이 벡터 자료형은 스택과 유사하게 사용 가능
  - .push_back(n), .pop_back() 식으로 활용 가능
  - .size(), .empty()도 활용 가능
  - 하지만 삭제와 삽입이 빈번할 경우 차라리 stack이나 deque를 쓰는게 훨씬 낫다.
  - 일단은 여기까지. 지금은 STL까지 딥하게 배울 상황은 아닌듯.
- 하지만 만약 헤더 제한이 있거나 하는 경우, 그냥 **전역으로 넉넉하게 배열 할당해버리는 게 제일 편하기는 하다!**

## 추가로 배울 거

- stack, queue 라이브러리 배우기