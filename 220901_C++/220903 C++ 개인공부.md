## 삼성 SW 역량테스트 B형은...

- 예제 문제만으로 분석했을 때 기준

  - 예제의 경우 숫자야구 게임에 대해 분석 AI를 짜라고 하는 문제였음.
  - '**협업**'에 테마를 맞춘 느낌으로, 이미 일부 제작된 프로그램에 나만의 알고리즘 코드를 맞춰서 제작해 넣어야 하는 문제였음. (~~즉 조원들이 똥싼걸 내가 마무리짓는 조별과제 같은 느낌~~)
  - 특이하게도 '정답'이 정해져 있지 않고, 예제 출력(유추 횟수)이 합격 커트라인 정도인 느낌임.
    - 이같은 이유는 애초에 출력 코드조차 정해져 있어서, 예제보다 더 우수한 분석 알고리즘을 제작한다면 예시 출력보다 더 뛰어난 결과값이 나올 수 있다는 것을 나타내는 것으로 추정됨.

  - 따라서 주어진 코드를 분석해야 하고 이미 존재하는 함수를 이용해야 한다는 점은 까다롭지만, <u>일단 분석만 깔끔하게 해낼 수 있다면 오히려 기존 문제들보다 더 자유롭게 풀 수도 있을 것임</u>.
  - 또한 2개의 코드로 프로그램이 분리되어 있는데, 임시로 extern 함수(외부 파일에 그 함수가 있다는 것을 알려주는 것으로 보임)를 지우고 메인 프로그램에 직접 만든 프로그램 부분을 집어 넣으면 1개의 코드로도 프로그램을 동작시킬 수 있을 것으로 추정됨.
    - 혹은 프로그램을 분리해서 구동하는 방법을 배우는 쪽도 나을 것임.
      - 메인이 있는 쪽에 #include "otherprogram.cpp" 식으로 적어야 할 것 같다... 
    - 단 우려되는 것은 헤더를 아예 쓸 수 없다는 사실로, 오로지 <stdio.h> 뿐이기 때문에 sort(), qsort()조차도 사용 불가능할 것으로 추정됨. (두 정렬 함수는 algorithm, 혹은 stdlib.h를 필수적으로 사용해야 함)

## C++ 구조체 사용법

```cpp
class namedata{
    public:
    string name, phone, location;
    namedata(string name, string phone, string location){
        this->name = name;
        this->phone = phone;
        this->location = location;
    }
    namedata(){} // 이걸 넣어야 생성과 할당을 따로 따로 할 수 있음.
    private:
};
```

- 소문자 class 뒤에 이름을 적고 {}로 감싸기, **오직 클래스만 끝날때 세미콜론(;)을 필수로 붙여야 한다.**
- public:으로 적은 공간은 외부에서 호출 가능, private:로 적은 공간은 외부에서 호출 불가
  - **안타깝게도 public:을 생략할 순 없음;** 
  - 아래의 정렬 기능을 사용하려면 다른 함수에서 클래스 내부의 변수를 들여다봐야 하는데, 명시되지 않으면 변수는 기본적으로 private로 적용되는 것으로 추정
- 클래스에서 사용할 변수를 먼저 선언해준 뒤 생성자를 적어준다.
  - 파이썬과는 다르게 그냥 클래스 이름을 한번 더 적으면 생성자로 처리됨
  - ()안에 사용할 변수를 죽 적어준다.
  - this->변수 = 변수 식이다. 자바와 비슷하면서도 다르니 주의...
- 이후 생성자를 (){} 식으로 한번 더 적으면 선언을 먼저 따로, 할당은 나중에 할 수 있다.

```cpp
namedata cls[n]; // 먼저 생성을 해 두고...
for (int i=0; i<n; i++){
    cin >> in_n >> in_p >> in_l;
    cls[i] = namedata(in_n, in_p, in_l); // 나중에 할당!
}
```

## sort 쓰는 법

- **#include \<algorithm> 사용 필수!**

- int A[4] = {1, 3, 2, 4};
- sort(A, A + 4);
  - 배열을 포인터처럼 생각해서 배열 변수, 변수 + 길이를 인자로 넣을 것!
  - sort(A, A+4, greater<>()); 로 적으면 내림차순 정렬 가능
  - 3번째 인자에 bool 함수를 넣으면 커스텀 정렬 가능!
    - 함수의 리턴은 return a<b 식으로, 앞쪽 인자가 뒤쪽 인자보다 작은 식으로 설정할 것! 
- 커스텀 정렬 함수를 이용해 구조체의 특정 변수 기준으로 정렬하기

```cpp
bool cmp(namedata a, namedata b){
    return a.name < b.name;
}
...
sort(cls, cls+n, cmp);
```

## python 하다와서 헷갈리는 것

- if (0<= nx < y) 식으로 쓸 수는 없다... 분리해서 if (0 <= nx && nx < y )식으로 써야 함
- if (!n) 식으로 not 구문을 쓸 수 있음. 마찬가지로 0이 false, 나머지 값이 true 판정
  - false, true를 소문자로 써야 함!
  - 중첩될 때는 괄호 꼬박꼬박 붙이기! if(!(0>nx) && nx <y) 식으로 써야 안 헷갈림
- if조건문 뒤의 구문이 한 줄이면 그 다음줄에 들여쓰기 해서 쓰고 {}를 생략 가능
  - 사실 보닌이 그런 경우에는 한 줄에 몰아적기를 즐겨 써서 잘 안할거 같음;
- 문자열을 쓸 때 ""만 사용 가능, '' 사용 불가.

## String 사용법?

- #include \<string> 사용
  - s.substr(0, 1); => 0부터 1개의 글자를 잘라 string으로 저장할 수 있음
    - 첫번째 항목은 시작 위치, **두번째 항목은 글자 길이**인 것에 주의할 것!
  - stoi(s); => string 구문을 int형으로 바꿀 수 있음
    - 반대로 바꾸는 구문은 to_string(n);

## 포인터 복습?

- 포인터 선언과 할당 방법, 선언과 동시에 할당할 때는 int *pa = a, 나중에 할당할 때는 &을 사용

  - 나중에 할당할 때 *을 쓰면 아예 안 먹음;;;

  ```cpp
  #include <iostream>
  using namespace std;
  
  int *pa;
  
  int main()
  {
      int a = 1;
      pa = &a;
      a = 2;
      cout << *pa << endl;
  }
  ```

-  &는 그 변수의 주소값, *는 그 주소가 가리키는 변수

  - 그 변수가 저장된 메모리 상의 주소를 직접 찾아가기 때문에 서로 다른 함수라도 주소값을 받으면 찾아갈 수 있는 것.

## 배열을 한번에 같은 숫자로 초기화하려면?

- memset()을 쓰자!

  - 순서대로 배열 이름, 초기화 값, sizeof(이름)으로 사용.

  ```cpp
  int arr[10];
  memset(arr, 0, sizeof(arr));
  ```

- 주의사항! **되도록 0과 -1만 사용할 것!**

  - for문을 돌리는 것보다 약 5배정도 빠르지만, 그 과정에서 꼼수를 쓰기 때문에 아무 값이나 넣으면 초기화 자체가 이상하게 들어감...
    - 0b5f890393 => 0b5f 식으로 앞 두글자만 자름 => 0b5f5f5f5f 식으로 만듦
    - 0과 -1은 0b00000000, 0b11111111이므로 걱정없는 것.

## vector 헤더를 이용한 다차원 배열 사용법

- C++에서는 다차원 배열의 동적 할당을 못 하게 막아 두었다.
  - 사용하려면 1차원 배열을 대신 써서 다음과 같이 해야 함
    - 선언 : int *lst = new int[n * m];
    - 함수 호출 : def(lst)
    - 함수에서 사용 : void chunk(int* lst)
    - 해제 : delete lst

- 그래서 다차원 배열을 원래 쓰던 감각처럼 쓸 수 있는 STL의 vector 헤더를 사용!

```cpp
#include <vector>
// 선언과 동시에 할당하며 초기화
int n, m;
cin >> n >> m;
vector<vector<int>> lst(n, vector<int>(m, 0));
// 윗 구문 맨 뒤의 0은 초기값임! 안 적어줘도 원래 0으로 초기화되므로 걱정 말고 쓸 것!
// 선언과 할당을 따로 할 경우
vector<vector<int>> lst;
lst.resize(n, 0);
for (vector<int>&sub : lst) // 파이썬의 list 순회와 유사한 느낌.
    sub.resize(m,0);
// 함수 선언과 호출이 필요할 때는?
void mydef(int n, int m, vector<vector<int>> &lst) // 주소를 받기 때문에 지역으로 할당해도 사용가능
    mydef(n, m, lst);
```

- 덤 : 이 벡터 자료형은 스택과 유사하게 사용 가능
  - .push_back(n), .pop_back() 식으로 활용 가능
  - .size(), .empty()도 활용 가능
  - 하지만 삭제와 삽입이 빈번할 경우 차라리 stack이나 deque를 쓰는게 훨씬 낫다.
  - 일단은 여기까지. 지금은 STL까지 딥하게 배울 상황은 아닌듯.
- 하지만 만약 헤더 제한이 있거나 하는 경우, 그냥 **전역으로 넉넉하게 배열 할당해버리는 게 제일 편하기는 하다!**

## 추가로 배울 거

- stack, queue 라이브러리 배우기